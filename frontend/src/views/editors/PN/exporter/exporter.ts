import EventBus from "diagram-js/lib/core/EventBus";
import {
    isPlace,
    isTransition,
    isFlow
} from "../elements/pertiElementFactory"

import {v4 as uuidv4} from 'uuid';

function template(strings, ...keys){
    return (...values) => {
        const dict = values[values.length - 1] || {};
        const result = [strings[0]];
        keys.forEach((key, i) => {
          const value = Number.isInteger(key) ? values[key] : dict[key];
          result.push(value, strings[i + 1]);
        });
        return result.join("");
      };
}

const PNML_URL = "http://www.pnml.org/version-2009/grammar/pnmlcoremodel"

const XML_HEAD = 
`<?xml version="1.0" encoding="UTF-8"?>
<pnml>
<net type="${PNML_URL}" id="Generated by Petri Net Editor">
    <name>
        <text>Generated by Petri Net Editor</text>
    </name>
    <page id="page-1">
`

const XML_TAIL = 
`   </page>
</net>
</pnml>
`

const PLACE_TEMPLATE = 
template`       <place id="${"id"}">
            <name>
                <text>${"name"}</text>
            </name>
            <graphics>
                <position x="${"x"}" y="${"y"}"/>
            </graphics>
            <toolspecific tool="ProM" version="6.4" localNodeID="${"UUID"}" />
`

const PLACE_INITIAL_MARKING =
template`           <initialMarking>
                <text>${"marking"}</text>
            </initialMarking>
`

const PLACE_FINAL_MARKING =
template`           <finalMarking>
                <text>${"marking"}</text>
            </finalMarking>
`

const PLACE_CLOSURE = 
`       </place>
`

const TRANSITION_TEMPLATE = 
template`       <transition id="${"id"}" invisible="${"silent"}">
            <name>
                <text>${"name"}</text>
            </name>
            <graphics>
                <position x="${"x"}" y="${"y"}"/>
            </graphics>
            <toolspecific tool="ProM" version="6.4" localNodeID="${"UUID"}" activity="${"activity"}"/>
`

const TRANSITION_CLOSURE =
`       </transition>
`

const FLOW_TEMPLATE = 
template`       <arc id="${"id"}" source="${"src"}" target="${"tgt"}">
            <toolspecific tool="ProM" version="6.4" localNodeID="${"UUID"}" />
            <arctype>
                <text>normal</text>
            </arctype>
            <graphics>            
`

const FLOW_WAYPOINT = 
template`                <position x="${"x"}" y="${"y"}"/>
`

const FLOW_CLOSURE =
`           </graphics>       
        </arc>
`


const XML_ILLEGALS = {
    '&' : '&amp;',
    '<' : '&lt;',
    '>' : '&gt;',
    "'" : '&apos;',
    '"' : '&quot;'
}

export type PREFIX = "exporting."
export type SUFFIX = "export"
export type EVENTS = `${PREFIX}${SUFFIX}`

export default class Exporting {
    
    static $inject = [
        'eventBus',
        'elementRegistry'
    ]

    _bus: EventBus<any> 
    _registry: any
    _xml: string

    constructor(eventBus, registry){
        this._bus = eventBus
        this._registry = registry
        this._xml = ""

        this._bus.on('exporting.export', this.export.bind(this));
    }

    fire(event: EVENTS){
        return this._bus.fire(event)
    }

    encode(text){
        var ret = text
        for(const illegal in XML_ILLEGALS){
            ret = ret.replace(
                illegal, XML_ILLEGALS[illegal]
            )
        }
        return ret
    }

    export(){
        this._xml = this.createHead()
        var that = this
        // process places first
        var check = isPlace
        var els = this._registry.filter(check)
        var f = function(el,gfx) {
            return that.serialise(that,el,gfx)
        }
        els.forEach(f)
        // then transitions 
        check = isTransition
        els = this._registry.filter(check)
        var f = function(el,gfx) {
            return that.serialise(that,el,gfx)
        }
        els.forEach(f)
        // then flows
        check = isFlow
        els = this._registry.filter(check)
        var f = function(el,gfx) {
            return that.serialise(that,el,gfx)
        }
        els.forEach(f)

        //TODO
        // then add initial marking
        // then add final marking

        return this._xml + this.createTail()
    }

    createHead(){
        return XML_HEAD
    }

    serialise(self, element, gfx){
        if (isPlace(element)){
            self._xml += self._serialisePlace(self, element, gfx)
        } else if (isTransition(element)){
            self._xml += self._serialiseTransition(self, element, gfx)
        } else if (isFlow(element)){
            self._xml += self._serialiseFlow(self, element, gfx)
        } else {
            console.error(`Unknown element type: ${element.type}`)
        }
    }

    _serialisePlace(self, element, gfx){
        var UUID = uuidv4()
        var placeSvg = ""+ PLACE_TEMPLATE({
            id: element.id,
            name: element.id,
            x: parseInt(element.x),
            y: parseInt(element.y),
            UUID: UUID
        })
        // TODO
        // check for initial marking
        // check for final marking

        return placeSvg + PLACE_CLOSURE
    }

    _serialiseTransition(self, element, gfx){
        var UUID = uuidv4()
        var transitionSvg = ""+ TRANSITION_TEMPLATE({
            id: element.id,
            name: element.labelText,
            silent: element.silent,
            x: parseInt(element.x),
            y: parseInt(element.y),
            activity: element.silent ? "$invisible$" : "",
            UUID: UUID
        })
        return transitionSvg + TRANSITION_CLOSURE
    }

    _serialiseFlow(self, element, gfx){
        var UUID = uuidv4()
        var flowSvg = ""+ FLOW_TEMPLATE({
            id: element.id,
            src: element.source.id,
            tgt: element.target.id,
            UUID: UUID
        })
        for(var way of element.waypoints){
            flowSvg += FLOW_WAYPOINT({
                x: parseInt(way.x),
                y: parseInt(way.y)
            })
        }
        return flowSvg + FLOW_CLOSURE
    }

    createTail(){
        return XML_TAIL
    }
}